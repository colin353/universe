use parser::FieldType;

const DONOTEDIT: &'static str = r#"/*
 * DO NOT EDIT THIS FILE
 *
 * It was generated by bus's code generator
 *
 */

// Allow dead code, since we're generating structs/accessors
#![allow(dead_code)]
#![allow(unused_imports)]
"#;

const IMPORTS: &'static str = r#"
use bus::{
    Deserialize, DeserializeOwned, EncodedStruct, EncodedStructBuilder, RepeatedField,
    RepeatedFieldIterator, RepeatedBytes, RepeatedString, Serialize, PackedIn, PackedOut
};

"#;

pub fn generate<W: std::io::Write>(
    module: &parser::Module,
    w: &mut W,
) -> Result<(), std::io::Error> {
    write!(w, "{}", DONOTEDIT)?;
    write!(w, "{}", IMPORTS)?;

    for e in &module.enums {
        generate_enum(&e, w)?;
    }

    for message in &module.messages {
        generate_message(&message, w)?;
    }

    Ok(())
}

fn get_type_name(f: &parser::FieldDefinition) -> String {
    let typ = match &f.field_type {
        FieldType::Tu64 => "u64",
        FieldType::Tu32 => "u32",
        FieldType::Tu16 => "u16",
        FieldType::Tu8 => "u8",
        FieldType::Tbool => "bool",
        FieldType::Tstring => "String",
        FieldType::Tfloat => "f32",
        FieldType::Tbytes => "Vec<u8>",
        FieldType::Message(s) => s.as_str(),
        FieldType::Enum(s) => s.as_str(),
        FieldType::Other(s) => s.as_str(),
    };

    let typ = if let FieldType::Message(_) = &f.field_type {
        format!("{}", typ)
    } else {
        typ.to_owned()
    };

    if f.repeated {
        format!("Vec<{}>", typ)
    } else {
        typ
    }
}

fn get_return_type_name(f: &parser::FieldDefinition) -> String {
    let typ = match &f.field_type {
        FieldType::Tu64 => "u64",
        FieldType::Tu32 => "u32",
        FieldType::Tu16 => "u16",
        FieldType::Tu8 => "u8",
        FieldType::Tbool => "bool",
        FieldType::Tstring => "&str",
        FieldType::Tfloat => "f32",
        FieldType::Tbytes => "&[u8]",
        FieldType::Message(s) => s.as_str(),
        FieldType::Enum(s) => s.as_str(),
        FieldType::Other(s) => s.as_str(),
    };
    if f.repeated {
        format!("RepeatedField<'a, {}>", typ)
    } else if let FieldType::Message(_) = &f.field_type {
        format!("{}", typ)
    } else {
        typ.to_owned()
    }
}

fn generate_enum<W: std::io::Write>(
    e: &parser::EnumDefinition,
    w: &mut W,
) -> Result<(), std::io::Error> {
    // Define the enum
    write!(
        w,
        "#[derive(Clone, Debug, Copy, PartialEq)]
enum {name} {{
",
        name = e.name
    )?;

    let mut zero_name = String::from("Unknown");
    let mut has_zero_tag = false;
    for (field, tag) in &e.fields {
        write!(w, "    {fname},\n", fname = field)?;

        if *tag == 0 {
            has_zero_tag = true;
            zero_name = field.clone();
        }
    }
    if !has_zero_tag {
        write!(w, "    Unknown,\n")?;
    }
    write!(w, "}}\n\n")?;

    // Implement Default
    write!(
        w,
        "impl Default for {name} {{
    fn default() -> Self {{
        Self::{zero_name}
    }}
}}

",
        name = e.name,
        zero_name = zero_name,
    )?;

    // Implement Serialize
    write!(
        w,
        "impl Serialize for {name} {{
    fn encode<W: std::io::Write>(&self, writer: &mut W) -> Result<usize, std::io::Error> {{
        let value = match self {{
",
        name = e.name,
    )?;

    for (field, tag) in &e.fields {
        if *tag == 0 {
            write!(
                w,
                "            Self::{field} => return Ok(0),\n",
                field = field,
            )?;
        } else {
            write!(
                w,
                "            Self::{field} => {tag},\n",
                field = field,
                tag = tag
            )?;
        }
    }

    write!(
        w,
        "        }};
        writer.write_all(&[value])?;
        Ok(1)
    }}
}}

"
    )?;

    // Implement Deserialize
    write!(
        w,
        "impl DeserializeOwned for {name} {{
    fn decode_owned(bytes: &[u8]) -> Result<Self, std::io::Error> {{
        if bytes.len() == 0 {{
            return Ok(Self::{zero_name})
        }}
        match bytes[0] {{
",
        name = e.name,
        zero_name = zero_name,
    )?;

    for (field, tag) in &e.fields {
        if *tag != 0 {
            write!(
                w,
                "            {tag} => Ok(Self::{field}),\n",
                field = field,
                tag = tag
            )?;
        }
    }

    write!(
        w,
        "            _ => Ok(Self::{zero_name}),
        }}
    }}
}}

",
        zero_name = zero_name
    )?;

    Ok(())
}

fn generate_message<W: std::io::Write>(
    msg: &parser::MessageDefinition,
    w: &mut W,
) -> Result<(), std::io::Error> {
    write!(
        w,
        r#"#[derive(Clone, Debug, Default)]
pub struct {name} {{
"#,
        name = msg.name
    )?;
    for field in &msg.fields {
        let typ = get_type_name(&field);

        write!(
            w,
            "    pub {name}: {typ},\n",
            name = field.field_name,
            typ = typ
        )?;
    }
    write!(w, "}}\n\n")?;

    write!(
        w,
        r#"#[derive(Clone, Copy)]
pub enum {name}View<'a> {{
    Encoded(EncodedStruct<'a>),
    Decoded(&'a {name}),
}}

"#,
        name = msg.name
    )?;

    // Implement Debug for the enum type
    write!(
        w,
        r#"impl<'a> std::fmt::Debug for {name}View<'a> {{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        f.debug_struct("{name}")
"#,
        name = msg.name
    )?;

    for (_, field) in msg.fields.iter().enumerate() {
        write!(
            w,
            r#"            .field("{field_name}", &self.get_{field_name}())
"#,
            field_name = field.field_name
        )?;
    }

    write!(
        w,
        "            .finish()
    }}
}}

"
    )?;

    // Implement Serialize for the owned version
    write!(w, "impl Serialize for {name} {{\n", name = msg.name)?;

    write!(
        w,
        r#"    fn encode<W: std::io::Write>(&self, writer: &mut W) -> Result<usize, std::io::Error> {{
        let mut builder = EncodedStructBuilder::new(writer);
"#,
    )?;

    let mut idx = 0;
    for field in &msg.fields {
        for _ in idx..field.tag {
            write!(w, "        builder.advance();\n",)?;
        }
        idx = field.tag + 1;

        if field.field_type == FieldType::Tbytes {
            write!(
                w,
                "        builder.push(PackedOut(&self.{field_name}))?;\n",
                field_name = field.field_name
            )?;
        } else {
            write!(
                w,
                "        builder.push(&self.{field_name})?;\n",
                field_name = field.field_name
            )?;
        }
    }

    write!(
        w,
        "        builder.finish()
    }}
}}

impl DeserializeOwned for {name} {{
",
        name = msg.name,
    )?;

    write!(
        w,
        r#"    fn decode_owned(bytes: &[u8]) -> Result<Self, std::io::Error> {{
        let s = EncodedStruct::new(bytes)?;
        Ok(Self {{
"#,
    )?;

    for field in &msg.fields {
        if field.field_type == FieldType::Tbytes {
            write!(
                w,
                "            {field_name}: {{
                let p: PackedIn<{typ}> = s.get_owned({idx}).transpose()?.unwrap_or_default();
                p.0
            }},
",
                field_name = field.field_name,
                idx = field.tag,
                typ = if field.repeated { "Vec<u8>" } else { "u8" }
            )?;
        } else {
            write!(
                w,
                "            {field_name}: s.get_owned({idx}).transpose()?.unwrap_or_default(),\n",
                field_name = field.field_name,
                idx = field.tag,
            )?;
        }
    }

    write!(
        w,
        r#"        }})
    }}
}}
"#,
    )?;

    // Implement Deserialize for the view
    write!(
        w,
        r#"impl<'a> Deserialize<'a> for {name}View<'a> {{
    fn decode(bytes: &'a [u8]) -> Result<Self, std::io::Error> {{
        Ok(Self::Encoded(EncodedStruct::from_bytes(bytes)?))
    }}
}}
"#,
        name = msg.name
    )?;

    // Define repeated struct
    write!(
        w,
        r#"enum Repeated{name}<'a> {{
    Encoded(RepeatedField<'a, {name}View<'a>>),
    Decoded(&'a [{name}]),
}}

impl<'a> std::fmt::Debug for Repeated{name}<'a> {{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        match self {{
            Self::Encoded(v) => {{
                write!(f, "[")?;
                let mut first = true;
                for item in v {{
                    if first {{
                        first = false;
                    }} else {{
                        write!(f, ", ")?;
                    }}
                    write!(f, "{{:?}}", item)?;
                }}
                write!(f, "]")
            }}
            Self::Decoded(v) => v.fmt(f),
        }}
    }}
}}

enum Repeated{name}Iterator<'a> {{
    Encoded(RepeatedFieldIterator<'a, {name}View<'a>>),
    Decoded(std::slice::Iter<'a, {name}>),
}}

impl<'a> Repeated{name}<'a> {{
    pub fn iter(&'a self) -> Repeated{name}Iterator<'a> {{
        match self {{
            Self::Encoded(r) => Repeated{name}Iterator::Encoded(r.iter()),
            Self::Decoded(s) => Repeated{name}Iterator::Decoded(s.iter()),
        }}
    }}
}}

impl<'a> Iterator for Repeated{name}Iterator<'a> {{
    type Item = {name}View<'a>;
    fn next(&mut self) -> Option<Self::Item> {{
        match self {{
            Self::Encoded(it) => it.next(),
            Self::Decoded(it) => Some({name}View::Decoded(it.next()?)),
        }}
    }}
}}

"#,
        name = msg.name
    )?;

    // Implement owned version
    write!(
        w,
        r#"impl {name} {{
    pub fn new() -> Self {{
        Self::default()
    }}

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, std::io::Error> {{
        {name}View::from_bytes(bytes)?.to_owned()
    }}

    pub fn as_view<'a>(&'a self) -> {name}View {{
        {name}View::Decoded(self)
    }}
}}
"#,
        name = msg.name
    )?;

    // Implement view version
    write!(w, "impl<'a> {name}View<'a> {{\n", name = msg.name)?;

    // Implement from_bytes constructor
    write!(
        w,
        r#"    pub fn from_bytes(bytes: &'a [u8]) -> Result<Self, std::io::Error> {{
        Ok(Self::Encoded(EncodedStruct::new(bytes)?))
    }}
"#
    )?;

    // Implement to_owned, which converts to an owned type
    write!(
        w,
        r#"    pub fn to_owned(&self) -> Result<{name}, std::io::Error> {{
        match self {{
            Self::Decoded(t) => Ok((*t).clone()),
            Self::Encoded(t) => Ok({name} {{
"#,
        name = msg.name,
    )?;

    for field in &msg.fields {
        write!(
            w,
            "                {field_name}: t.get_owned({idx}).transpose()?.unwrap_or_default(),\n",
            field_name = field.field_name,
            idx = field.tag,
        )?;
    }

    write!(
        w,
        r#"            }}),
        }}
    }}
"#,
    )?;

    write!(
        w,
        r#"    pub fn encode<W: std::io::Write>(&self, writer: &mut W) -> Result<usize, std::io::Error> {{
        match self {{
            Self::Decoded(t) => t.encode(writer),
            Self::Encoded(t) => t.encode(writer),
        }}
    }}
"#
    )?;

    // Implement field getters
    for field in &msg.fields {
        let mut typ = get_return_type_name(&field);
        if field.repeated {
            if let FieldType::Message(s) = &field.field_type {
                typ = format!("Repeated{name}<'a>", name = s);
            } else if field.field_type == FieldType::Tstring {
                typ = String::from("RepeatedString<'a>");
            } else if field.field_type == FieldType::Tbytes {
                typ = String::from("RepeatedBytes<'a>");
            }
        } else if let FieldType::Message(s) = &field.field_type {
            typ = format!("{name}View<'a>", name = s);
        }

        write!(
            w,
            r#"    pub fn get_{name}(&'a self) -> {field_type} {{
        match self {{
"#,
            name = field.field_name,
            field_type = typ
        )?;

        if let FieldType::Message(s) = &field.field_type {
            if field.repeated {
                write!(
                    w,
                    r#"            Self::Decoded(x) => Repeated{field_type}::Decoded(&x.{name}.as_slice()),
            Self::Encoded(x) => Repeated{field_type}::Encoded(RepeatedField::Encoded(x.get({idx}).transpose().unwrap_or_default().unwrap_or_default())),
"#,
                    field_type = s,
                    name = field.field_name,
                    idx = field.tag,
                )?;
            } else {
                write!(
                    w,
                    r#"           Self::Decoded(x) => {field_type}View::Decoded(&x.{name}),
            Self::Encoded(x) => {field_type}View::Encoded(x.get({idx}).transpose().unwrap_or_default().unwrap_or_default()),
"#,
                    name = field.field_name,
                    field_type = s,
                    idx = field.tag,
                )?;
            }
        } else if field.repeated {
            if field.field_type == FieldType::Tstring {
                write!(
                    w,
                    r#"            Self::Decoded(x) => RepeatedString::Decoded(x.{name}.as_slice()),
            Self::Encoded(x) => RepeatedString::Encoded(x.get({idx}).transpose().unwrap_or_default().unwrap_or_default()),
"#,
                    name = field.field_name,
                    idx = field.tag,
                )?;
            } else if field.field_type == FieldType::Tbytes {
                write!(
                    w,
                    r#"            Self::Decoded(x) => RepeatedBytes::Decoded(x.{name}.as_slice()),
            Self::Encoded(x) => RepeatedBytes::Encoded(x.get({idx}).transpose().unwrap_or_default().unwrap_or_default()),
"#,
                    name = field.field_name,
                    idx = field.tag,
                )?;
            } else {
                write!(
                    w,
                    r#"            Self::Decoded(x) => RepeatedField::Decoded(x.{name}.as_slice()),
            Self::Encoded(x) => RepeatedField::Encoded(x.get({idx}).transpose().unwrap_or_default().unwrap_or_default()),
"#,
                    name = field.field_name,
                    idx = field.tag,
                )?;
            }
        } else if field.field_type == FieldType::Tstring {
            write!(
                w,
                r#"            Self::Decoded(x) => x.{name}.as_str(),
            Self::Encoded(x) => x.get({idx}).transpose().unwrap_or_default().unwrap_or_default(),
"#,
                name = field.field_name,
                idx = field.tag,
            )?;
        } else if field.field_type == FieldType::Tbytes {
            write!(
                w,
                r#"            Self::Decoded(x) => &x.{name},
            Self::Encoded(x) => x.get({idx}).transpose().unwrap_or_default().unwrap_or_default(),
"#,
                name = field.field_name,
                idx = field.tag,
            )?;
        } else {
            write!(
                w,
                r#"            Self::Decoded(x) => x.{name},
            Self::Encoded(x) => x.get({idx}).transpose().unwrap_or_default().unwrap_or_default(),
"#,
                name = field.field_name,
                idx = field.tag,
            )?;
        }

        write!(w, "        }}\n    }}\n")?;
    }

    write!(w, "}}\n")?;

    Ok(())
}

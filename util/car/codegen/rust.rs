use parser::FieldType;

const DONOTEDIT: &'static str = r#"/*
 * DO NOT EDIT THIS FILE
 *
 * It was generated by car's code generator
 *
 */

// TODO: remove this
mod test_test;
"#;

const IMPORTS: &'static str = r#"
use car::{
    Deserialize, DeserializeOwned, EncodedStruct, EncodedStructBuilder, RepeatedField, Serialize,
};

"#;

pub fn generate<W: std::io::Write>(
    module: &parser::Module,
    w: &mut W,
) -> Result<(), std::io::Error> {
    write!(w, "{}", DONOTEDIT);
    write!(w, "{}", IMPORTS);

    for message in &module.messages {
        generate_message(&message, w)?;
    }

    Ok(())
}

fn get_type_name(f: &parser::FieldDefinition) -> String {
    let typ = match &f.field_type {
        FieldType::Tu64 => "u64",
        FieldType::Tu32 => "u32",
        FieldType::Tu16 => "u16",
        FieldType::Tu8 => "u8",
        FieldType::Tbool => "bool",
        FieldType::Tstring => "String",
        FieldType::Tfloat => "f32",
        FieldType::Tbytes => "Vec<u8>",
        FieldType::Other(s) => s.as_str(),
    };

    let typ = if let FieldType::Other(s) = &f.field_type {
        format!("{}Owned", typ)
    } else {
        typ.to_owned()
    };

    if f.repeated {
        format!("Vec<{}>", typ)
    } else {
        typ
    }
}

fn get_return_type_name(f: &parser::FieldDefinition) -> String {
    let typ = match &f.field_type {
        FieldType::Tu64 => "u64",
        FieldType::Tu32 => "u32",
        FieldType::Tu16 => "u16",
        FieldType::Tu8 => "u8",
        FieldType::Tbool => "bool",
        FieldType::Tstring => "&str",
        FieldType::Tfloat => "f32",
        FieldType::Tbytes => "&[u8]",
        FieldType::Other(s) => s.as_str(),
    };
    if f.repeated {
        format!("RepeatedField<'a, {}>", typ)
    } else if let FieldType::Other(_) = &f.field_type {
        format!("{}", typ)
    } else {
        typ.to_owned()
    }
}

fn generate_message<W: std::io::Write>(
    msg: &parser::MessageDefinition,
    w: &mut W,
) -> Result<(), std::io::Error> {
    write!(
        w,
        r#"#[derive(Clone, Default)]
struct {name}Owned {{
"#,
        name = msg.name
    );
    for field in &msg.fields {
        let typ = get_type_name(&field);

        write!(
            w,
            "    {name}: {typ},\n",
            name = field.field_name,
            typ = typ
        );
    }
    write!(w, "}}\n");

    write!(
        w,
        r#"#[derive(Clone)]
enum {name}<'a> {{
    Encoded(EncodedStruct<'a>),
    DecodedOwned(Box<{name}Owned>),
    DecodedReference(&'a {name}Owned),
}}

impl<'a> Default for {name}<'a> {{
    fn default() -> Self {{
        Self::DecodedOwned(Box::new({name}Owned::default()))
    }}
}}

"#,
        name = msg.name
    );

    // Implement Serialize for the owned version
    write!(w, "impl Serialize for {name}Owned {{\n", name = msg.name);

    write!(
        w,
        r#"    fn encode<W: std::io::Write>(&self, writer: &mut W) -> Result<usize, std::io::Error> {{
        let mut builder = EncodedStructBuilder::new(writer);
"#,
    );

    for (idx, field) in msg.fields.iter().enumerate() {
        write!(
            w,
            "        builder.push(&self.{field_name})?;\n",
            field_name = field.field_name
        );
    }

    write!(
        w,
        "        builder.finish()
    }}
}}

impl DeserializeOwned for {name}Owned {{
",
        name = msg.name,
    );

    write!(
        w,
        r#"    fn decode_owned(bytes: &[u8]) -> Result<Self, std::io::Error> {{
        let s = EncodedStruct::new(bytes)?;
        Ok(Self {{
"#,
    );

    for (idx, field) in msg.fields.iter().enumerate() {
        write!(
            w,
            "            {field_name}: s.get_owned({idx}).unwrap()?,\n",
            field_name = field.field_name,
            idx = idx,
        );
    }

    write!(
        w,
        r#"        }})
    }}
}}
"#,
    );

    // Implement enum version
    write!(w, "impl<'a> {name}<'a> {{\n", name = msg.name);

    // Implement new constructor
    write!(
        w,
        r#"    pub fn new() -> Self {{
        Self::DecodedOwned(Box::new({name}Owned {{
            ..Default::default()
        }}))
    }}
"#,
        name = msg.name
    );

    // Implement from_bytes constructor
    write!(
        w,
        r#"    pub fn from_bytes(bytes: &'a [u8]) -> Result<Self, std::io::Error> {{
        Ok(Self::Encoded(EncodedStruct::new(bytes)?))
    }}
"#
    );

    // Implement to_owned, which converts to an owned type
    write!(
        w,
        r#"    pub fn to_owned(&self) -> Result<Self, std::io::Error> {{
        match self {{
            Self::DecodedOwned(t) => Ok(Self::DecodedOwned(t.clone())),
            Self::DecodedReference(t) => Ok(Self::DecodedOwned(Box::new((*t).clone()))),
            Self::Encoded(t) => Ok(Self::DecodedOwned(Box::new(self.clone_owned()?))),
        }}
    }}

    pub fn clone_owned(&self) -> Result<{name}Owned, std::io::Error> {{
        match self {{
            Self::DecodedOwned(t) => Ok(t.as_ref().clone()),
            Self::DecodedReference(t) => Ok((*t).clone()),
            Self::Encoded(t) => Ok({name}Owned {{
"#,
        name = msg.name,
    );

    for (idx, field) in msg.fields.iter().enumerate() {
        write!(
            w,
            "                {field_name}: t.get_owned({idx}).unwrap()?,\n",
            field_name = field.field_name,
            idx = idx,
        );
    }

    write!(
        w,
        r#"            }}),
        }}
    }}
"#,
    );

    write!(
        w,
        r#"    pub fn encode<W: std::io::Write>(&self, writer: &mut W) -> Result<usize, std::io::Error> {{
        match self {{
            Self::DecodedOwned(t) => t.encode(writer),
            Self::DecodedReference(t) => t.encode(writer),
            Self::Encoded(t) => t.encode(writer),
        }}
    }}
"#
    );

    // Implement field getters
    for (idx, field) in msg.fields.iter().enumerate() {
        let owned_type = get_type_name(&field);
        let mut typ = get_return_type_name(&field);

        write!(
            w,
            r#"    pub fn get_{name}(&'a self) -> {field_type} {{
        match self {{
"#,
            name = field.field_name,
            field_type = typ
        );

        if field.repeated {
            write!(
                w,
                r#"            Self::DecodedOwned(x) => RepeatedField::DecodedReference(x.{name}.as_slice()),
            Self::DecodedReference(x) => RepeatedField::DecodedReference(x.{name}.as_slice()),
"#,
                name = field.field_name,
            );

            write!(
                w,
                r#"            Self::Encoded(x) => RepeatedField::Encoded(x.get({idx}).unwrap().unwrap()),
        }}
    }}
"#,
                idx = idx,
            );
        } else if let FieldType::Other(s) = &field.field_type {
            write!(
                w,
                r#"            Self::DecodedOwned(x) => {field_type}::DecodedReference(&x.{name}),
            Self::DecodedReference(x) => {field_type}::DecodedReference(&x.{name}),
"#,
                name = field.field_name,
                field_type = typ,
            );

            write!(
                w,
                r#"            Self::Encoded(x) => {name}::Encoded(x.get({idx}).unwrap().unwrap()),
        }}
    }}
"#,
                name = s,
                idx = idx,
            );
        } else if field.field_type == FieldType::Tstring {
            write!(
                w,
                r#"            Self::DecodedOwned(x) => x.{name}.as_str(),
            Self::DecodedReference(x) => x.{name}.as_str(),

"#,
                name = field.field_name,
            );

            write!(
                w,
                r#"            Self::Encoded(x) => x.get({idx}).unwrap().unwrap(),
        }}
    }}
"#,
                idx = idx,
            );
        } else {
            write!(
                w,
                r#"            Self::DecodedOwned(x) => x.{name},
            Self::DecodedReference(x) => x.{name},

"#,
                name = field.field_name,
            );

            write!(
                w,
                r#"            Self::Encoded(x) => x.get({idx}).unwrap().unwrap(),
        }}
    }}
"#,
                idx = idx,
            );
        }

        // Implement setters
        if let FieldType::Other(s) = &field.field_type {
            write!(
                w,
                r#"    pub fn set_{name}(&mut self, value: {field_type}) -> Result<(), std::io::Error> {{
        match self {{
            Self::Encoded(_) | Self::DecodedReference(_) => {{
                *self = self.to_owned()?;
                self.set_{name}(value);
            }}
            Self::DecodedOwned(v) => {{
                v.{name} = value.clone_owned()?;
            }}
        }}
        Ok(())
    }}
"#,
                name = field.field_name,
                field_type = s
            );
        } else {
            write!(
                w,
                r#"    pub fn set_{name}(&mut self, value: {field_type}) -> Result<(), std::io::Error> {{
        match self {{
            Self::Encoded(_) | Self::DecodedReference(_) => {{
                *self = self.to_owned()?;
                self.set_{name}(value);
            }}
            Self::DecodedOwned(v) => {{
                v.{name} = value;
            }}
        }}
        Ok(())
    }}
"#,
                name = field.field_name,
                field_type = owned_type
            );
        }

        // Implement mut_... accessors
        if field.repeated {
            write!(
                w,
                r#"    pub fn mut_{name}(&mut self) -> Result<&mut {field_type}, std::io::Error> {{
        match self {{
            Self::Encoded(_) | Self::DecodedReference(_) => {{
                *self = self.to_owned()?;
                self.mut_{name}()
            }}
            Self::DecodedOwned(v) => {{
                Ok(&mut v.{name})
            }}
        }}
    }}
"#,
                name = field.field_name,
                field_type = owned_type,
            );
        } else if let FieldType::Other(s) = &field.field_type {
            write!(
                w,
                r#"    pub fn mut_{name}(&mut self) -> Result<&mut {field_type}Owned, std::io::Error> {{
        match self {{
            Self::Encoded(_) | Self::DecodedReference(_) => {{
                *self = self.to_owned()?;
                self.mut_{name}()
            }}
            Self::DecodedOwned(v) => {{
                Ok(&mut v.{name})
            }}
        }}
    }}
"#,
                name = field.field_name,
                field_type = s,
            );
        }
    }

    write!(w, "}}\n");

    Ok(())
}

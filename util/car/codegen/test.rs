/*
 * DO NOT EDIT THIS FILE
 *
 * It was generated by car's code generator
 *
 */

// TODO: remove this
mod test_test;


use car::{EncodedStruct, EncodedStructBuilder, RepeatedField, Serialize, Deserialize, DeserializeOwned};

#[derive(Clone, Default)]
struct ZootOwned {
    toot: TootOwned,
    size: Vec<u64>,
}
#[derive(Clone)]
enum Zoot<'a> {
    Encoded(EncodedStruct<'a>),
    DecodedOwned(ZootOwned),
    DecodedReference(&'a ZootOwned),
}

impl<'a> Default for Zoot<'a> {
    fn default() -> Self {
        Self::DecodedOwned(ZootOwned::default())
    }
}

impl Serialize for ZootOwned {
    fn encode<W: std::io::Write>(&self, writer: &mut W) -> Result<usize, std::io::Error> {
        let mut builder = EncodedStructBuilder::new(writer);
    builder.push(&self.toot)?;
    builder.push(&self.size)?;
    builder.finish()
    }
}

impl DeserializeOwned for ZootOwned {
    fn decode_owned(bytes: &[u8]) -> Result<Self, std::io::Error> {
        unimplemented!()
    }
}
impl<'a> Zoot<'a> {
    pub fn new() -> Self {
        Self::DecodedOwned(ZootOwned {
            ..Default::default()
        })
    }
    pub fn from_bytes(bytes: &'a [u8]) -> Result<Self, std::io::Error> {
        Ok(Self::Encoded(EncodedStruct::new(bytes)?))
    }
    pub fn to_owned(&self) -> Self {
        match self {
            Self::DecodedOwned(t) => Self::DecodedOwned(t.clone()),
            Self::DecodedReference(t) => Self::DecodedOwned((*t).clone()),
            Self::Encoded(t) => {
                unimplemented!()
            }
        }
    }

    pub fn clone_owned(&self) -> ZootOwned {
        match self {
            Self::DecodedOwned(t) => t.clone(),
            Self::DecodedReference(t) => (*t).clone(),
            Self::Encoded(t) => {
                unimplemented!()
            }
        }
    }
    pub fn encode<W: std::io::Write>(&self, writer: &mut W) -> Result<usize, std::io::Error> {
        match self {
            Self::DecodedOwned(t) => t.encode(writer),
            Self::DecodedReference(t) => t.encode(writer),
            Self::Encoded(t) => t.encode(writer),
        }
    }
    pub fn get_toot(&'a self) -> Toot {
        match self {
            Self::DecodedOwned(x) => Toot::DecodedReference(&x.toot),
            Self::DecodedReference(x) => Toot::DecodedReference(&x.toot),
            Self::Encoded(x) => Toot::Encoded(x.get(0).unwrap().unwrap()),
        }
    }
    pub fn set_toot(&mut self, value: Toot) {
        match self {
            Self::Encoded(_) | Self::DecodedReference(_) => {
                *self = self.to_owned();
                self.set_toot(value);
            }
            Self::DecodedOwned(v) => {
                v.toot = value.clone_owned();
            }
        }
    }
    pub fn get_size(&'a self) -> RepeatedField<'a, u64> {
        match self {
            Self::DecodedOwned(x) => RepeatedField::DecodedReference(x.size.as_slice()),
            Self::DecodedReference(x) => RepeatedField::DecodedReference(x.size.as_slice()),
            Self::Encoded(x) => RepeatedField::Encoded(x.get(1).unwrap().unwrap()),
        }
    }
    pub fn set_size(&mut self, value: Vec<u64>) {
        match self {
            Self::Encoded(_) | Self::DecodedReference(_) => {
                *self = self.to_owned();
                self.set_size(value);
            }
            Self::DecodedOwned(v) => {
                v.size = value;
            }
        }
    }
}
#[derive(Clone, Default)]
struct TootOwned {
    id: u32,
}
#[derive(Clone)]
enum Toot<'a> {
    Encoded(EncodedStruct<'a>),
    DecodedOwned(TootOwned),
    DecodedReference(&'a TootOwned),
}

impl<'a> Default for Toot<'a> {
    fn default() -> Self {
        Self::DecodedOwned(TootOwned::default())
    }
}

impl Serialize for TootOwned {
    fn encode<W: std::io::Write>(&self, writer: &mut W) -> Result<usize, std::io::Error> {
        let mut builder = EncodedStructBuilder::new(writer);
    builder.push(&self.id)?;
    builder.finish()
    }
}

impl DeserializeOwned for TootOwned {
    fn decode_owned(bytes: &[u8]) -> Result<Self, std::io::Error> {
        unimplemented!()
    }
}
impl<'a> Toot<'a> {
    pub fn new() -> Self {
        Self::DecodedOwned(TootOwned {
            ..Default::default()
        })
    }
    pub fn from_bytes(bytes: &'a [u8]) -> Result<Self, std::io::Error> {
        Ok(Self::Encoded(EncodedStruct::new(bytes)?))
    }
    pub fn to_owned(&self) -> Self {
        match self {
            Self::DecodedOwned(t) => Self::DecodedOwned(t.clone()),
            Self::DecodedReference(t) => Self::DecodedOwned((*t).clone()),
            Self::Encoded(t) => {
                unimplemented!()
            }
        }
    }

    pub fn clone_owned(&self) -> TootOwned {
        match self {
            Self::DecodedOwned(t) => t.clone(),
            Self::DecodedReference(t) => (*t).clone(),
            Self::Encoded(t) => {
                unimplemented!()
            }
        }
    }
    pub fn encode<W: std::io::Write>(&self, writer: &mut W) -> Result<usize, std::io::Error> {
        match self {
            Self::DecodedOwned(t) => t.encode(writer),
            Self::DecodedReference(t) => t.encode(writer),
            Self::Encoded(t) => t.encode(writer),
        }
    }
    pub fn get_id(&'a self) -> u32 {
        match self {
            Self::DecodedOwned(x) => x.id,
            Self::DecodedReference(x) => x.id,

            Self::Encoded(x) => x.get(0).unwrap().unwrap(),
        }
    }
    pub fn set_id(&mut self, value: u32) {
        match self {
            Self::Encoded(_) | Self::DecodedReference(_) => {
                *self = self.to_owned();
                self.set_id(value);
            }
            Self::DecodedOwned(v) => {
                v.id = value;
            }
        }
    }
}
